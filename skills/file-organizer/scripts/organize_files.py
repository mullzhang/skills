#!/usr/bin/env python3
"""
Organize files based on grouping plan.

This script moves files into organized directories based on a grouping plan.
The plan is typically generated by Claude based on file analysis.
"""

import os
import json
import argparse
import shutil
from pathlib import Path
from typing import Dict, List, Any


def create_directory_safely(path: Path) -> None:
    """Create a directory if it doesn't exist."""
    path.mkdir(parents=True, exist_ok=True)


def move_file(source: Path, destination: Path, copy: bool = False) -> bool:
    """
    Move or copy a file to destination.

    Args:
        source: Source file path
        destination: Destination file path
        copy: If True, copy instead of move

    Returns:
        True if successful, False otherwise
    """
    try:
        # Create destination directory if needed
        destination.parent.mkdir(parents=True, exist_ok=True)

        # Handle filename conflicts
        if destination.exists():
            stem = destination.stem
            suffix = destination.suffix
            counter = 1
            while destination.exists():
                destination = destination.parent / f"{stem}_{counter}{suffix}"
                counter += 1

        if copy:
            shutil.copy2(source, destination)
            print(f"✓ Copied: {source.name} → {destination}")
        else:
            shutil.move(str(source), str(destination))
            print(f"✓ Moved: {source.name} → {destination}")

        return True

    except Exception as e:
        print(f"✗ Error processing {source.name}: {e}")
        return False


def organize_files(plan: Dict[str, Any], dry_run: bool = False, copy: bool = False) -> Dict[str, Any]:
    """
    Organize files according to the grouping plan.

    Args:
        plan: Grouping plan dictionary with structure:
            {
                "base_directory": "/path/to/target",
                "groups": {
                    "GroupName": {
                        "description": "Description of group",
                        "files": ["/path/to/file1", "/path/to/file2"]
                    }
                }
            }
        dry_run: If True, don't actually move files, just show what would happen
        copy: If True, copy files instead of moving them

    Returns:
        Dictionary with results
    """
    base_dir = Path(plan.get("base_directory", ".")).expanduser().resolve()
    groups = plan.get("groups", {})

    results = {
        "total_files": 0,
        "successful": 0,
        "failed": 0,
        "skipped": 0,
        "groups": {},
    }

    for group_name, group_info in groups.items():
        group_dir = base_dir / group_name
        files = group_info.get("files", [])
        description = group_info.get("description", "")

        print(f"\n{'='*60}")
        print(f"Group: {group_name}")
        if description:
            print(f"Description: {description}")
        print(f"Target: {group_dir}")
        print(f"Files: {len(files)}")
        print(f"{'='*60}")

        group_results = {
            "directory": str(group_dir),
            "description": description,
            "total": len(files),
            "successful": 0,
            "failed": 0,
        }

        if not dry_run:
            create_directory_safely(group_dir)

        for file_path_str in files:
            file_path = Path(file_path_str).expanduser().resolve()
            results["total_files"] += 1

            if not file_path.exists():
                print(f"✗ File not found: {file_path.name}")
                results["failed"] += 1
                group_results["failed"] += 1
                continue

            if not file_path.is_file():
                print(f"⊘ Skipped (not a file): {file_path.name}")
                results["skipped"] += 1
                continue

            destination = group_dir / file_path.name

            if dry_run:
                action = "Copy" if copy else "Move"
                print(f"[DRY RUN] Would {action.lower()}: {file_path.name} → {destination}")
                results["successful"] += 1
                group_results["successful"] += 1
            else:
                if move_file(file_path, destination, copy=copy):
                    results["successful"] += 1
                    group_results["successful"] += 1
                else:
                    results["failed"] += 1
                    group_results["failed"] += 1

        results["groups"][group_name] = group_results

    return results


def main():
    parser = argparse.ArgumentParser(
        description="Organize files based on a grouping plan"
    )
    parser.add_argument(
        "plan",
        help="JSON file containing the grouping plan"
    )
    parser.add_argument(
        "-n", "--dry-run",
        action="store_true",
        help="Show what would be done without actually moving files"
    )
    parser.add_argument(
        "-c", "--copy",
        action="store_true",
        help="Copy files instead of moving them"
    )
    parser.add_argument(
        "-o", "--output",
        help="Save results to JSON file"
    )

    args = parser.parse_args()

    try:
        # Load the plan
        with open(args.plan, "r", encoding="utf-8") as f:
            plan = json.load(f)

        # Organize files
        if args.dry_run:
            print("\n" + "="*60)
            print("DRY RUN MODE - No files will be moved")
            print("="*60)

        results = organize_files(plan, dry_run=args.dry_run, copy=args.copy)

        # Print summary
        print("\n" + "="*60)
        print("SUMMARY")
        print("="*60)
        print(f"Total files: {results['total_files']}")
        print(f"Successful: {results['successful']}")
        print(f"Failed: {results['failed']}")
        print(f"Skipped: {results['skipped']}")

        # Save results if requested
        if args.output:
            with open(args.output, "w", encoding="utf-8") as f:
                json.dumps(results, f, indent=2, ensure_ascii=False)
            print(f"\nResults saved to: {args.output}")

        return 0 if results["failed"] == 0 else 1

    except Exception as e:
        print(f"Error: {e}")
        return 1


if __name__ == "__main__":
    exit(main())
